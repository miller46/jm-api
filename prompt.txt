Create an integration test suite for the jm-api FastAPI application. Tests start a real uvicorn server, connect to a file-based SQLite database, and send real HTTP requests over TCP via `httpx.Client`.

## Task 1: Configure pytest isolation

Update `pyproject.toml` `[tool.pytest.ini_options]`:

```toml
markers = ["integration: full-stack integration tests (start real server)"]
addopts = "-q -m 'not integration'"
```

This ensures `uv run pytest` skips integration tests by default. Run them explicitly:

```bash
uv run pytest tests/integration/ -m integration
```

## Task 2: Create `tests/integration/conftest.py`

Implement these fixtures:

### `integration_server` (session scope)

1. Set env var `JM_API_DATABASE_URL` to `sqlite:///tmp/jm_integration_test.db`.
2. Call `get_settings.cache_clear()` (from `jm_api.core.config`) so the app picks up the test DB URL.
3. Create engine with `create_engine(settings.database_url)` and run `Base.metadata.create_all(engine)` (import `Base` from `jm_api.db.base`).
4. Start uvicorn serving `jm_api.main:app` on `127.0.0.1` with a free port in a background thread:
   - Use `uvicorn.Config` + `uvicorn.Server`.
   - Find a free port via `socket.bind(("127.0.0.1", 0))`.
   - Run `server.serve()` in a `threading.Thread(daemon=True)`.
5. Poll `GET /api/v1/healthz` with retries (max 30 attempts, 0.1s sleep) until 200.
6. Yield the base URL string: `http://127.0.0.1:{port}`.
7. Teardown: call `server.should_exit = True`, join thread, run `Base.metadata.drop_all(engine)`, `engine.dispose()`, delete the SQLite file.

### `base_url` (session scope)

Return the URL string from `integration_server`.

### `http_client` (function scope)

Yield an `httpx.Client(base_url=base_url)`. Close on teardown.

### `db_session` (function scope)

Create a SQLAlchemy `Session` bound to the integration engine. Yield it. Rollback and close on teardown.

Mark every fixture that depends on `integration_server` with `@pytest.mark.integration`.

## Task 3: Write integration tests in `tests/integration/test_integration.py`

Mark every test with `@pytest.mark.integration`.

### Health endpoint tests

Test: `GET /api/v1/healthz` returns status 200 with body `{"status": "ok"}`.

Test: `GET /api/v1/healthz` response includes an `X-Request-ID` header (non-empty string).

### Bot endpoint tests

Reference info â€” the `Bot` model (`jm_api.models.bot`) has columns: `id` (str, auto-generated), `rig_id` (str), `kill_switch` (bool), `last_run_log` (str|None), `last_run_at` (datetime|None), `create_at` (datetime, auto), `last_update_at` (datetime, auto).

The list endpoint returns `ListResponse` shape: `{"items": [...], "total": int, "page": int, "per_page": int, "pages": int}`.

Test: `GET /api/v1/bots` on empty DB returns 200 with `total` == 0 and `items` == [].

Test: Insert a `Bot` row directly via `db_session` (e.g. `Bot(rig_id="test-rig")`), commit, then `GET /api/v1/bots` returns it in `items` with matching `rig_id`.

Test: After inserting a bot, `GET /api/v1/bots/{id}` with that bot's ID returns 200 with matching `id` and `rig_id`.

Test: `GET /api/v1/bots/nonexistent-id-abc` returns 404.

Test: Insert two bots with different `rig_id` values. `GET /api/v1/bots?rig_id=test-rig-1` returns only the matching bot.

Test: Insert 3 bots. `GET /api/v1/bots?page=1&per_page=2` returns `per_page` == 2, `page` == 1, `pages` == 2, `total` == 3, and `len(items)` == 2.

## Constraints

- Use `httpx.Client` for all HTTP requests (not `TestClient`). Import from `httpx`.
- Use standard `assert` statements (no unittest-style assertions).
- Use `uv run` for all CLI commands.
- Do not modify any existing files in `tests/`. The only existing file to modify is `pyproject.toml`.
- Place all new files under `tests/integration/`.
